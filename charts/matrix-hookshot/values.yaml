---
# Default values for test.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: halfshot/matrix-hookshot
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

# podSecurityContext:
#   fsGroup: 2000
podSecurityContext: {}

# securityContext:
#   capabilities:
#     drop:
#     - ALL
#   readOnlyRootFilesystem: true
#   runAsNonRoot: true
#   runAsUser: 1000
securityContext: {}

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # Type of the service
  type: ClusterIP

  # Fixed ip address of the load balancer
  # loadbalancerIP: ""

  # Extra annotations for service
  annotations: {}

  # Extra labels for service
  labels: {}

  ports:
    # Webhook port as configured in container
    webhook:
      port: 9000
      containerPort: 9000
      protocol: TCP

    # Metrics port as configured in container
    metrics:
      port: 9001
      containerPort: 9001
      protocol: TCP

    # Appservice port as configured in container
    appservice:
      port: 9002
      containerPort: 9002
      protocol: TCP

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  webhook:
    # Enable ingress for webhook
    enabled: false
    # Ingress class name for webhook ingress
    className: ""
    # Annotations for webhook ingress
    annotations: {}
    # Host configuration for webhook ingress
    hosts: []
    # TLS configuration for webhook ingress
    tls: []
  appservice:
    # Enable ingress for appservice
    enabled: false
    # Ingress class name for appservice ingress
    className: ""
    # Annotations for appservice ingress
    annotations: {}
    # Host configuration for appservice ingress
    hosts: []
    # TLS configuration for appservice ingress
    tls: []

# We usually recommend not to specify default resources and to leave this as a conscious
# choice for the user. This also increases chances charts run on environments with little
# resources, such as Minikube. If you do want to specify resources, uncomment the following
# lines, adjust them as necessary, and remove the curly braces after 'resources:'.
# resources:
#   limits:
#     cpu: 100m
#     memory: 128Mi
#   requests:
#     cpu: 100m
#     memory: 128Mi
resources: {}

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: appservice
readinessProbe:
  httpGet:
    path: /
    port: appservice

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes mounted to the StatefulSet.
# extraVolumes:
# - name: foo
#   persistentVolumeClaim:
#     claimName: mysecret
# - name: foo
#   hostPath: example
# - name: foo
extraVolumes: []

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

# Redis settings
# Valid if encryption.enabled: true
# redis: {}

hookshot:
  # Name of existing ConfigMap with valid Hookshot configuration
  existingSecret: {}

  # Enable encryption support
  # Means we will start a redis cluster and create pvc for the persistent state
  encryption:
    enabled: false

    persistence:
      accessModes:
        - ReadWriteOnce
      storageClassName: default
      storageSize: 10Gi

  # Raw Hookshot configuration. Gets templated into a YAML file and then loaded unless an existingConfigMap is specified.
  config:
    # This is an example configuration file
    bridge:
      # Basic homeserver configuration
      domain: example.com
      url: http://localhost:8008
      mediaUrl: https://example.com
      port: 9993
      bindAddress: 127.0.0.1
    passFile: passkey.pem
    # A passkey used to encrypt tokens stored inside the bridge.
    # Run openssl genpkey -out passkey.pem -outform PEM -algorithm RSA -pkeyopt rsa_keygen_bits:4096 to generate
    logging:
      # Logging settings. You can have a severity debug,info,warn,error
      level: info
      colorize: true
      json: false
      timestampFormat: HH:mm:ss:SSS
    listeners:
      # HTTP Listener configuration.
      # Bind resource endpoints to ports and addresses.
      # 'port' must be specified. Each listener must listen on a unique port.
      # 'bindAddress' will default to '127.0.0.1' if not specified, which may not be suited to Docker environments.
      # 'resources' may be any of webhooks, widgets, metrics, provisioning
      - port: 9000
        bindAddress: 0.0.0.0
        resources:
          - webhooks
      - port: 9001
        bindAddress: 127.0.0.1
        resources:
          - metrics
          - provisioning
      - port: 9002
        bindAddress: 0.0.0.0
        resources:
          - widgets

    #github:
    #  # (Optional) Configure this to enable GitHub support
    #  auth:
    #    # Authentication for the GitHub App.
    #    id: 123
    #    privateKeyFile: github-key.pem
    #  webhook:
    #    # Webhook settings for the GitHub app.
    #    secret: secrettoken
    #  oauth:
    #    # (Optional) Settings for allowing users to sign in via OAuth.
    #    client_id: foo
    #    client_secret: bar
    #    redirect_uri: https://example.com/oauth/
    #  defaultOptions:
    #    # (Optional) Default options for GitHub connections.
    #    showIssueRoomLink: false
    #    hotlinkIssues:
    #      prefix: "#"
    #  userIdPrefix:
    #    # (Optional) Prefix used when creating ghost users for GitHub accounts.
    #    _github_

    #gitlab:
    #  # (Optional) Configure this to enable GitLab support
    #  instances:
    #    gitlab.com:
    #      url: https://gitlab.com
    #  webhook:
    #    secret: secrettoken
    #    publicUrl: https://example.com/hookshot/
    #  userIdPrefix:
    #    # (Optional) Prefix used when creating ghost users for GitLab accounts.
    #    _gitlab_
    #  commentDebounceMs:
    #    # (Optional) Aggregate comments by waiting this many miliseconds before posting them to Matrix. Defaults to 5000 (5 seconds)
    #    5000

    #figma:
    #  # (Optional) Configure this to enable Figma support
    #  publicUrl: https://example.com/hookshot/
    #  instances:
    #    your-instance:
    #      teamId: your-team-id
    #      accessToken: your-personal-access-token
    #      passcode: your-webhook-passcode

    #jira:
    #  # (Optional) Configure this to enable Jira support. Only specify `url` if you are using a On Premise install (i.e. not atlassian.com)
    #  webhook:
    #    # Webhook settings for JIRA
    #    secret: secrettoken
    #  oauth:
    #    # (Optional) OAuth settings for connecting users to JIRA. See documentation for more information
    #    client_id: foo
    #    client_secret: bar
    #    redirect_uri: https://example.com/oauth/

    #generic:
    #  # (Optional) Support for generic webhook events.
    #  #'allowJsTransformationFunctions' will allow users to write short transformation snippets in code, and thus is unsafe in untrusted environments

    #  enabled: false
    #  enableHttpGet: false
    #  urlPrefix: https://example.com/webhook/
    #  userIdPrefix: _webhooks_
    #  allowJsTransformationFunctions: false
    #  waitForComplete: false

    #feeds:
    #  # (Optional) Configure this to enable RSS/Atom feed support
    #  enabled: false
    #  pollConcurrency: 4
    #  pollIntervalSeconds: 600
    #  pollTimeoutSeconds: 30

    #provisioning:
    #  # (Optional) Provisioning API for integration managers
    #  secret: "!secretToken"

    #bot:
    #  # (Optional) Define profile information for the bot user
    #  displayname: Hookshot Bot
    #  avatar: mxc://half-shot.uk/2876e89ccade4cb615e210c458e2a7a6883fe17d

    #serviceBots:
    #  # (Optional) Define additional bot users for specific services
    #  - localpart: feeds
    #    displayname: Feeds
    #    avatar: ./assets/feeds_avatar.png
    #    prefix: "!feeds"
    #    service: feeds

    #metrics:
    #  # (Optional) Prometheus metrics support
    #  enabled: true

    #cache:
    #  # (Optional) Cache options for large scale deployments.
    #  # For encryption to work, this must be configured.
    #  redisUri: redis://localhost:6379

    #queue:
    #  # (Optional) Message queue configuration options for large scale deployments.
    #  # For encryption to work, this must not be configured.
    #  redisUri: redis://localhost:6379

    #widgets:
    #  # (Optional) EXPERIMENTAL support for complimentary widgets
    #  addToAdminRooms: false
    #  disallowedIpRanges:
    #    - 127.0.0.0/8
    #    - 10.0.0.0/8
    #    - 172.16.0.0/12
    #    - 192.168.0.0/16
    #    - 100.64.0.0/10
    #    - 192.0.0.0/24
    #    - 169.254.0.0/16
    #    - 192.88.99.0/24
    #    - 198.18.0.0/15
    #    - 192.0.2.0/24
    #    - 198.51.100.0/24
    #    - 203.0.113.0/24
    #    - 224.0.0.0/4
    #    - ::1/128
    #    - fe80::/10
    #    - fc00::/7
    #    - 2001:db8::/32
    #    - ff00::/8
    #    - fec0::/10
    #  roomSetupWidget:
    #    addOnInvite: false
    #  publicUrl: https://example.com/widgetapi/v1/static/
    #  branding:
    #    widgetTitle: Hookshot Configuration

    #sentry:
    #  # (Optional) Configure Sentry error reporting
    #  dsn: https://examplePublicKey@o0.ingest.sentry.io/0
    #  environment: production

    #permissions:
    #  # (Optional) Permissions for using the bridge. See docs/setup.md#permissions for help
    #  - actor: example.com
    #    services:
    #      - service: "*"
    #        level: admin

  registration:
    id: matrix-hookshot
    as_token: ""
    hs_token: ""
    namespaces:
      rooms: []
      users: []
    sender_localpart: hookshot
    url: "http://example.com"
    rate_limited: false
  passkey: ""
